<script>
  // Read URL params
  const q = new URLSearchParams(location.search);
  const params = {
    players: q.get('players'),
    position: (q.get('position') || '').toUpperCase(),
    hand: (q.get('hand') || '').toUpperCase(),
    situation: (q.get('situation') || '').toLowerCase(),
    limpers: q.get('limpers'),
    openSize: q.get('openSize'),
    openPos: q.get('openPos'),
    openCallers: q.get('openCallers'),
    threeBetSize: q.get('threeBetSize'),
    threeBetIP: q.get('threeBetIP'),
    threeBetCallers: q.get('threeBetCallers'),
    style: q.get('style') || 'standard',
    bluffing: q.get('bluffing') || 'normal'
  };

  // Context + back link
  document.getElementById('ctx').textContent =
    `Table: ${params.players} • Position: ${params.position} • Hand: ${params.hand} • Situation: ${params.situation}`;
  const back = document.getElementById('back');
  const backURL = new URL('/action.html', location.origin);
  Object.entries(params).forEach(([k,v]) => { if(v) backURL.searchParams.set(k, v); });
  back.href = backURL.toString();

  // ------- Punchy, scenario-aware fallbacks (one sentence each) -------
  function oneLineFold(p){
    const ip = /BTN|CO/.test(p.position);
    const oop = /SB|BB|UTG|MP/.test(p.position);
    const bigOpen = p.openSize && parseFloat(p.openSize) > 3.0;
    const big3b = p.threeBetSize && parseFloat(p.threeBetSize) >= 8.0;
    const multiway = (p.openCallers && p.openCallers !== '0') || (p.threeBetCallers && p.threeBetCallers !== '0');
    const lowBluff = p.bluffing === 'low';
    if (big3b && oop) return "Fold to large 3-bets out of position unless holding premiums.";
    if (bigOpen && !ip) return "Fold most marginal hands to big opens when you’re out of position.";
    let s = "Fold more when price is poor or ranges are tight";
    if (lowBluff) s += ", especially versus low-bluff opponents";
    if (multiway) s += ", and when the pot is likely multiway";
    return s + ".";
  }

  function oneLineCall(p){
    const ip = /BTN|CO/.test(p.position);
    const cheapOpen = p.openSize ? parseFloat(p.openSize) <= 3.0 : true;
    const bluffHigh = p.bluffing === 'high';
    let s = "Call in position at a good price";
    if (cheapOpen && ip && p.situation === 'raise') s += ` (≈${p.openSize || "small"}× opens)`;
    if (bluffHigh) s += ", especially versus bluff-heavy opponents";
    s += "; prefer suited/broadways, avoid dominated offsuit OOP.";
    return s;
  }

  function oneLineRaise(p){
    const ip = /BTN|CO/.test(p.position);
    const aggro = p.style === 'aggressive';
    let s = "Raise/3-bet premium or strong hands";
    if (ip) s += " in position";
    if (aggro) s += "; versus aggressive openers, value 3-bet rather than slow-play";
    if (p.situation === 'limped') s += "; isolate limpers from late position";
    return s + ".";
  }

  async function run(){
    const err = document.getElementById('error');
    const foldEl  = document.getElementById('fold_text');
    const callEl  = document.getElementById('call_text');
    const raiseEl = document.getElementById('raise_text');

    try{
      const apiURL = new URL('/api/decide', location.origin);
      Object.entries(params).forEach(([k,v]) => { if(v) apiURL.searchParams.set(k, v); });
      const resp = await fetch(apiURL.toString());
      if(!resp.ok) throw new Error(await resp.text());
      const data = await resp.json();

      // Short, scenario-specific text: prefer AI, fallback to our one-liners
      foldEl.textContent  = (data.fold_text  && data.fold_text.trim())  ? data.fold_text  : oneLineFold(params);
      callEl.textContent  = (data.call_text  && data.call_text.trim())  ? data.call_text  : oneLineCall(params);
      raiseEl.textContent = (data.raise_text && data.raise_text.trim()) ? data.raise_text : oneLineRaise(params);

      // Verdict
      const verdict = document.getElementById('verdict');
      const badge = document.getElementById('decisionBadge');
      const decisionText = document.getElementById('decisionText');
      const rationale = document.getElementById('rationale');

      decisionText.textContent = data.decision || '—';
      rationale.textContent = data.rationale || '';
      badge.className = 'badge';
      if(/fold/i.test(data.decision)) badge.classList.add('fold');
      else if(/call/i.test(data.decision)) badge.classList.add('call');
      verdict.style.display = '';
    } catch(e){
      err.style.display = 'block';
      err.textContent = 'Could not fetch AI decision. Showing tailored defaults.';
      foldEl.textContent  = oneLineFold(params);
      callEl.textContent  = oneLineCall(params);
      raiseEl.textContent = oneLineRaise(params);
      document.getElementById('verdict').style.display = 'none';
    }
  }

  run();
</script>
